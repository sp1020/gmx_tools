#!/usr/bin/env python3

# Standard library
from collections import Counter
import copy
import logging
import os
import shutil
import sys
import warnings
from typing import Any, Dict, List, Set, Tuple
import argparse

# Third-party
import pandas as pd
from Bio.PDB.PDBExceptions import PDBConstructionWarning
from Bio.PDB import PDBParser
from Bio.PDB import PDBIO, Structure, Model, Chain
from Bio.PDB.Residue import Residue

warnings.filterwarnings('ignore', category=PDBConstructionWarning)

class Atom:
    def __init__(self, name, type, charge, charge_group):
        self.name = name 
        self.type = type
        self.charge = charge
        self.charge_group = charge_group
        
    def __str__(self):
        return '\t'.join([self.name, self.type, self.charge, self.charge_group])
    
    
class ResidueTopology:
    def __init__(self):
        self.name = None
        self.atom_map = {}

        self.atoms = []
        self.bonds = []
        self.angles = []
        self.impropers = []
        self.dihedrals = []
        self.cmap = []

    def add_atom(self, stripped):
        s = stripped.split()
        name = s[0]
        type = s[1]
        charge = s[2]
        charge_group = s[3]
        self.atom_map[name] = Atom(name, type, charge, charge_group)
        self.atoms.append(name)

    def add_bond(self, stripped):
        """
        implemnetation only for bond type 1 
        """
        s = stripped.split()
        if s[0] in self.atom_map and s[1] in self.atom_map:
            self.bonds.append([s[0], s[1]])
        else:
            print('Error: missing atom in the bond:', stripped)

    def add_angle(self, stripped):
        """
        implemnetation only for angle type 5
        """

        print('Warning: angle is not expected for CGenFF generated force field')

    def add_improper(self, stripped):
        """
        implemnetation only for improper type 2
        """
        s = stripped.split()
        if s[0] in self.atom_map and s[1] in self.atom_map and s[2] in self.atom_map and s[3] in self.atom_map:
            self.impropers.append([s[0], s[1], s[2], s[3]])
        else:
            print('Error: missing atom in the improper:', stripped)

    def add_dihedral(self, stripped):
        """
        implemnetation only for dihedral type 9
        """
        s = stripped.split()
        if s[0] in self.atom_map and s[1] in self.atom_map and s[2] in self.atom_map and s[3] in self.atom_map:
            self.dihedrals.append([s[0], s[1], s[2], s[3]])
        else:
            print('Error: missing atom in the dihedral:', stripped)

    def add_cmap(self, stripped):
        s = stripped.split()
        if s[0] in self.atom_map and s[1] in self.atom_map and s[2] in self.atom_map and s[3] in self.atom_map and s[4] in self.atom_map:
            self.cmap.append([s[0], s[1], s[2], s[3], s[4]])
        else:
            print('Error: missing atom in the cmap:', stripped)
            
    def to_string(self):
        lines = f'[ {self.name} ]\n'
        
        # atoms 
        if len(self.atoms) > 0: 
            lines += '  [ atoms ]\n'
            for e in self.atoms:
                if e in self.atom_map:
                    lines += '    ' + str(self.atom_map[e]) + '\n'

        # bonds
        lines += '  [ bonds ]\n'
        lines += '    C\t+N\n' # peptide bonds
        for e in self.bonds:
            if e[0] in self.atom_map and e[1] in self.atom_map:
                lines += f'    {self.atom_map[e[0]].name}\t{self.atom_map[e[1]].name}\n'

        # impropers
        lines += '  [ impropers ]\n'
        lines += '    N\t-C\tCA\tHN\n'
        lines += '    C\tCA\t+N\tO\n'
        
        for e in self.impropers:
            if e[0] in self.atom_map and e[1] in self.atom_map and e[2] in self.atom_map and e[3] in self.atom_map:
                lines += f'    {self.atom_map[e[0]].name}\t{self.atom_map[e[1]].name}\t{self.atom_map[e[2]].name}\t{self.atom_map[e[3]].name}\n'
        
        return lines
            
            
class RTPHandler:
    def __init__(self, cgenff_dir, output_ff_dir, rtp_filename, pdb_filename, resn='UNK'):
        """
        A handler class for reading, modifying, and writing GROMACS RTP (residue topology) files for unnatural amino acids. 
        
        This class is designed to facilitate the integration of CGenFF generated force fields for non-standard (unnatural) residues into the GROMACS-compatible CHARMM36 force field format. 
        
        Parameters
        ----------
        
        ff_dir : str 
            Path to the force field directory containing the RTP files (charmm36.ff directory generated by CGenFF. 
        
        rtp_filename : str
            FileName of
            
        """
        # force field directory and rtp_filename 
        self.cgenff_dir = cgenff_dir
        self.output_ff_dir = output_ff_dir
        self.ff_dir = cgenff_dir + '/charmm36.ff'
        self.rtp_filename = rtp_filename
        self.pdb_filename = pdb_filename
        self.resn = resn
        
        # residue 
        self.bonded_type_lines = ''
        self.residue = None
        
        # copy directory to output_ff_dir 
        if os.path.exists(self.output_ff_dir):
            print('Error: The output directory already exists.')
            print('       Please remove it or choose a different directory before running the script.')
            sys.exit(1)
        shutil.copytree(self.cgenff_dir + '/charmm36.ff', self.output_ff_dir + '/charmm36.ff')
        
        # parse the RTP file 
        self.parse_rtp()
    
    def parse_rtp(self):
        """
        Parse the RTP file and extract residue topology information.
        
        This method reads the RTP file specified by `self.ff_dir` and `self.rtp_filename`,
        and stores the contents (atoms, bonds, angles) into `Residue` object. 
        
        The RTP file is assumbed to have a single residue information. 
        
        The parsed residue will be stored in `self.residue`. 
        
        """

        # RTP file 
        filepath = os.path.join(self.ff_dir, self.rtp_filename)
        
        current_section = None
        residue = None 

        with open(filepath, 'r') as file:
            for line in file:
                stripped = line.strip()

                # Skip empty lines or comments
                if not stripped or stripped.startswith(';'):
                    continue

                # Evaluate section
                if stripped.startswith('[') and stripped.endswith(']'):
                    current_section = stripped[1:-1].strip()
                    
                    if current_section == 'bondedtypes':
                        self.bonded_type_lines += line 
                    else:
                        if current_section == 'atoms':
                            pass
                        elif current_section == 'bonds':
                            pass
                        elif current_section == 'angles':
                            pass
                        elif current_section == 'impropers':
                            pass
                        elif current_section == 'dihedrals':
                            pass
                        elif current_section == 'cmap':
                            pass
                        else:
                            # a new residue topology 
                            r = ResidueTopology()
                            r.name = self.resn
                            residue = r 
                # Evaluate contents
                else:
                    if current_section == 'bondedtypes':
                        # within [ bondedtypes ] section
                        self.bonded_type_lines += line 
                    elif current_section is not None:
                        section_dispatch = {
                            'atoms': residue.add_atom, 
                            'bonds': residue.add_bond, 
                            'angles': residue.add_angle, 
                            'impropers': residue.add_improper, 
                            'dihedrals': residue.add_dihedral,
                            'cmap': residue.add_cmap,
                        }
                        handler = section_dispatch.get(current_section)
                        if handler:
                            handler(stripped)
                        else:
                            logging.debug(f"Unkonwn section [ {current_section} ]")
        self.residue = residue

    def _load_sheet(self, fp, name):
        df = pd.read_excel(fp, sheet_name=name)
        df['sheet_name'] = name
        return df

    def modify_rtp(self, filepath):
        tb_mc = pd.read_excel(filepath, sheet_name='rename_mc')
        tb_aa = pd.read_excel(filepath, sheet_name='rename_aa')
        tb_others = pd.read_excel(filepath, sheet_name='rename_others')
        tb_del = pd.read_excel(filepath, sheet_name='delete')
        
        # Print check up message
        print('Validating modifiction instructions...')
       
        # check existance of the atoms 
        atom_keys = self.residue.atom_map.keys()
        
        flag_err = False
        for e in tb_mc['name']: 
            if e not in atom_keys:
                print(f'Error: missing atom in rename_mc sheet: {e}')
                flag_err = True
        for e in tb_aa['name']: 
            if e not in atom_keys:
                print(f'Error: missing atom in rename_aa sheet: {e}')
                flag_err = True
        for e in tb_others['name']: 
            if e not in atom_keys:
                print(f'Error: missing atom in rename_others sheet: {e}')
                flag_err = True
        for e in tb_del['name']: 
            if e not in atom_keys:
                print(f'Error: missing atom in delete sheet: {e}')
                flag_err = True
                
        # check whethere the to be deleted atom is renamed 
        for e in tb_del['name']: 
            if e in tb_mc['name']: 
                print(f'Error: atom in rename_mc sheet also in deletion group: {e}')
                flag_err = True
            if e in tb_aa['name']: 
                print(f'Error: atom in rename_aa sheet also in deletion group: {e}')
                flag_err = True
            if e in tb_others['name']: 
                print(f'Error: atom in rename_others sheet also in deletion group: {e}')
                flag_err = True
        
        # check whether rename instruction is not provided 
        an_mod = set(tb_mc['name']).union(set(tb_aa['name'])).union(set(tb_others['name'])).union(set(tb_del['name']))
        diff = set(atom_keys) - an_mod
        if len(diff) != 0:
            print(f'Error: Rename instructure is not provided: {diff}')
            flag_err = True
        else:
            print('Modification instructions exist for all atoms.')
        
        # check overlapping of the renamed name 
        intra_dup , inter_dup = self.check_overlaps(list(tb_mc['modified_name']), list(tb_aa['modified_name']), list(tb_others['modified_name']))

        print('Intra duplicates:', intra_dup)
        print('Duplicates:', inter_dup)

        if len(inter_dup) == 0 and len(intra_dup) == 0: 
            print('All modification rules passed validation')
        else:
            flag_err = True
            print('Error: check modification instruction integrity')

        # Evaluation of the charge 
        charge_original_rtp = 0
        for an in atom_keys: 
            charge_original_rtp += float(self.residue.atom_map[an].charge)
        print('Total charge of atoms in the original RTP file: %.3f'%charge_original_rtp)
        
        charge_modification = 0 
        for id, row in tb_mc.iterrows():
            an = row['name']
            cg = float(row['charge'])
            charge_modification += cg

        for id, row in tb_aa.iterrows():
            an = row['name']
            cg = float(row['charge'])
            charge_modification += cg
        
        for id, row in tb_others.iterrows():
            an = row['name']
            cg = float(row['charge'])
            charge_modification += cg

        print('Total charge of atoms in the modified topology: %.3f'%charge_modification)

            
        # modify rtp 
        if not flag_err: 
            # modify rtp 
            ## 1. delete the atoms 
            for e in tb_del['name']:
                self.residue.atom_map.pop(e)
            
            ## update charge index
            ix = 0
            for a in self.residue.atom_map:
                self.residue.atom_map[a].charge_group = str(ix)
                ix += 1
            
            ## 2. rename main chain atoms 
            for id, row in tb_mc.iterrows():
                n = row['name']
                mn = row['modified_name']
                cg = '%.3f'%row['charge']
                self.residue.atom_map[n].name = mn
                self.residue.atom_map[n].charge = cg
            
            ## 3. rename amino acid atoms 
            for id, row in tb_aa.iterrows():
                n = row['name']
                mn = row['modified_name']
                cg = '%.3f'%row['charge']
                self.residue.atom_map[n].name = mn
                self.residue.atom_map[n].charge = cg

            ## 4. rename other atoms 
            for id, row in tb_others.iterrows():
                n = row['name']
                mn = row['modified_name']
                cg = '%.3f'%row['charge']
                self.residue.atom_map[n].name = mn
                self.residue.atom_map[n].charge = cg

        
    def check_overlaps(self, *lists: List[Any]) -> Tuple[Dict[int, Set[Any]], Dict[Any, int]]:
        """
        Given any number of lists, returns two things:
        1. intra_duplicates: a dict mapping list-index (0-based) to the set of items
            that appear more than once in that same list.
        2. inter_counts:   a dict mapping each item to the number of DIFFERENT lists
            it appears in (only items appearing in ≥2 lists are included).
        """
        # 1. Intra-list duplicates
        intra_duplicates: Dict[int, Set[Any]] = {}
        for idx, lst in enumerate(lists):
            cnt = Counter(lst)
            dupes = {item for item, c in cnt.items() if c > 1}
            if dupes:
                intra_duplicates[idx] = dupes

        # 2. Inter-list overlaps
        # Count in how many distinct lists each item appears
        appearance = Counter()
        for lst in lists:
            appearance.update(set(lst))
        # Keep only items in ≥2 lists
        inter_counts = {item: freq for item, freq in appearance.items() if freq > 1}

        return intra_duplicates, inter_counts
    
    def write_rtp(self):
        filepath = self.output_ff_dir + '/charmm36.ff/' + self.rtp_filename
        with open(filepath, 'w') as f:
            f.write('; generated by sphong')
            f.write(self.bonded_type_lines)
            f.write(self.residue.to_string())

    def convert_pdb(self, chain='A'):
        """
        Update pdb structure file for the residue.
        
        
        """
        
        filepath = self.cgenff_dir + '/' + self.pdb_filename
        filepath_out = self.output_ff_dir + '/' + self.pdb_filename        
        
        p = PDBParser()
        st = p.get_structure('uaa', filepath)
        new_residue = Residue((' ', 1, ' '), self.resn, ' ')
        for m in st:
            for c in m:
                for r in c:
                    for a in r:
                        an = a.get_name()
                        if an in self.residue.atom_map:
                            if self.residue.atom_map[an].name == 'HN':
                                # the main chain hydrogen should not be constructured 
                                # the atom will be automatically created by pdb2gmx
                                # -ignh option should not be used 
                                # instead the hydrogen atom of the other protein can be first removed before placing the unnatural amino acid
                                continue
                            nm = self.residue.atom_map[an].name.ljust(4)
                            a_m = copy.deepcopy(a)
                            a_m.id = nm
                            a_m._name = nm
                            a_m.fullname = nm
                            a_m.element = nm[0]
                            new_residue.add(a_m)    
                        else:
                            # deleted atom
                            pass

        # Save the residue as a PDB file
        struct = Structure.Structure(self.resn)
        model = Model.Model(0)
        ch = Chain.Chain(chain)

        struct.add(model)
        model.add(ch)
        ch.add(new_residue)

        io = PDBIO()
        io.set_structure(struct)
        io.save(filepath_out)
    
    def generate_residuetypes_file(self):
        with open(self.output_ff_dir+'/residuetypes.dat', 'w') as fout:
            with open(self.ff_dir+'/residuetypes.dat', 'r') as fin:
                for line in fin:
                    fout.write(line)
            fout.write(f'{self.residue.name}\tProtein\n')

def parse_args():
    parser = argparse.ArgumentParser(
        description="Build and insert an UAA residue RTP block from a CGenFF-generated force field."
    )
    # directories
    parser.add_argument(
        "--cgenff_dir",
        type=str,
        required=True,
        help="Path to the CGenFF-generated force field directory"
    )
    parser.add_argument(
        "--output_dir",
        type=str,
        required=True,
        help="Directory where the modified force field files will be written"
    )
    # filenames
    parser.add_argument(
        "--rtp_file",
        type=str,
        required=True,
        help="Name of the RTP file to modify (e.g. 'GLD.rtp', related to JOB name of CGenFF)"
    )
    parser.add_argument(
        "--pdb_file",
        type=str,
        required=True,
        help="Name of the PDB file containing the UAA structure"
    )
    parser.add_argument(
        "--mod_file",
        type=str,
        required=True,
        help="Name of the XLSX file containing instructions for residue modification"
    )
    # residue name
    parser.add_argument(
        "--resn",
        type=str,
        required=True,
        help="Three-letter residue name (e.g. UAA) to use in the RTP entry"
    )

    return parser.parse_args()

def main():
    args = parse_args()
    print("CGenFF dir:", args.cgenff_dir)
    print("Output dir:", args.output_dir)
    print("RTP file:", args.rtp_file)
    print("PDB file:", args.pdb_file)
    print("Modification file:", args.mod_file)
    print("Residue name:", args.resn)

    p = argparse.ArgumentParser()
    p.add_argument("input", help="PDB file to process")

    r = RTPHandler(args.cgenff_dir, args.output_dir, args.rtp_file, args.pdb_file, resn=args.resn)
    r.modify_rtp(args.mod_file)
    r.write_rtp()
    r.convert_pdb()
    r.generate_residuetypes_file()